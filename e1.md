## Parte A

### 1. Generalización simbólica (Reglas escritas del lenguaje)

Las reglas fundamentales de JavaScript incluyen:

-   **Tipado dinámico débil**: Variables pueden cambiar de tipo durante ejecución
-   **Hoisting**: Declaraciones de variables y funciones se "elevan" al inicio de su alcance
-   **Alcance de función y léxico**: Variables tienen alcance de función hasta ES5, léxico con `let/const` desde ES6
-   **Prototipos**: Herencia basada en prototipos, no en clases (aunque ES6 agregó azúcar sintáctico)
-   **First-class functions**: Las funciones son valores que pueden asignarse, pasarse como parámetros
-   **Coerción automática de tipos**: Conversiones implícitas
-   **Closures**: Las funciones mantienen referencias a variables de su alcance exterior
-   **Sin sobrecarga de operadores**: Los operadores tienen comportamientos fijos según el contexto

### 2. Creencias de los profesionales

La comunidad JavaScript considera superiores estas características:

-   **Flexibilidad extrema**: "JavaScript puede hacer cualquier cosa" - desde frontend hasta backend, mobile, desktop, etc.
-   **Curva de aprendizaje inicial suave**: Fácil empezar a escribir código sin conocimientos profundos
-   **Ecosistema NPM**: Millones de paquetes disponibles, "hay una librería para todo"
-   **Desarrollo rápido**: Prototipado veloz sin compilación, "hot reloading"
-   **Ubicuidad**: Único lenguaje que funciona nativamente en todos los navegadores
-   **Comunidad masiva**: Gran cantidad de recursos, tutoriales y soporte
-   **Evolución continua**: Nuevas funcionalidades con ES6+ que mejoran constantemente el lenguaje
-   **Full-stack capability**: Un solo lenguaje para toda la aplicación

## Parte B

### 1. Sintaxis y semántica bien definida / Documentación oficial

**Fortalezas:**

-   Estándar ECMAScript bien documentado y mantenido por Ecma International
-   Documentación oficial en MDN (Mozilla Developer Network) extremadamente completa
-   Sintaxis similar a C/Java, familiar para muchos desarrolladores

**Debilidades:**

-   Múltiples versiones (ES5, ES6+) con diferencias significativas
-   Comportamientos "extraños" bien documentados pero contraintuitivos

### 2. Comprobación del código

**Limitaciones:**

-   **No hay verificación de tipos nativa**: Errores de tipo solo aparecen en runtime
-   **Herramientas externas necesarias**: ESLint, JSHint para análisis estático
-   **TypeScript como solución**: Superset que agrega verificación de tipos
-   **Testing manual intensivo**: Requiere pruebas exhaustivas para detectar errores

### 3. Confiabilidad

**Problemas de confiabilidad:**

-   **Coerción de tipos impredecible**: `0 == false` pero `0 !== false`
-   **Hoisting confuso**: Las variables pueden usarse antes de ser declaradas
-   **Global scope pollution**: Variables globales accidentales
-   **Errores silenciosos**: Muchos errores no lanzan excepciones

**Mejoras en ES6+:**

-   `strict mode` para detectar más errores
-   `let/const` para mejor control de scope
-   Mejor manejo de errores con Promesas

### 4. Ortogonalidad

**Baja ortogonalidad:**

-   **Múltiples formas de hacer lo mismo**: `function`, arrow functions, function expressions
-   **Diferentes sistemas de herencia**: prototipos, clases ES6, patrones de módulo
-   **Inconsistencias**: `typeof null === "object"`, arrays son objetos
-   **Contexto dependiente**: Comportamiento de `this` cambia según el contexto

### 5. Consistencia y uniformidad

**Inconsistencias notables:**

-   **Operadores**: `+` para suma y concatenación, comportamiento dependiente del tipo
-   **Comparación**: `==` vs `===` con reglas de coerción complejas
-   **APIs del navegador**: Diferentes implementaciones entre navegadores (históricamente)
-   **Naming conventions**: CamelCase mezclado con snake_case en APIs nativas

**Mejoras recientes:**

-   ES6+ más consistente en "naming" y comportamiento
-   Estandarización de APIs del navegador

### 6. Extensibilidad y subconjuntos

**Altamente extensible:**

-   **Prototype-based**: Cualquier objeto puede ser extendido dinámicamente
-   **Monkey patching**: Modificación de objetos nativos
-   **Módulos ES6**: Sistema de módulos oficial
-   **NPM ecosystem**: Millones de extensiones disponibles

**Subconjuntos comunes:**

-   **Strict mode**: Subconjunto más estricto
-   **TypeScript**: Superset con tipos estáticos
-   **Flow**: Sistema de tipos alternativo
-   **JSX**: Extensión para React

### 7. Transportabilidad del código

**Excelente transportabilidad:**

-   **Interpretado**: No requiere compilación específica del sistema
-   **Estándar universal**: Funciona en cualquier navegador moderno
-   **Node.js**: Mismo código funciona en servidor
-   **Cross-platform**: Electron para desktop, React Native para mobile

**Limitaciones:**

-   **Diferencias de navegador**: Aunque menores con estándares modernos
-   **Versiones de ECMAScript**: Código ES6+ requiere transpilación para navegadores antiguos
-   **APIs específicas**: Código del navegador vs Node.js no siempre intercambiable
